import "./chunk-S5KM4IGW.js";

// node_modules/tom-select/dist/esm/tom-select.complete.js
function forEvents(events, callback) {
  events.split(/\s+/).forEach((event) => {
    callback(event);
  });
}
var MicroEvent = class {
  constructor() {
    this._events = {};
  }
  on(events, fct) {
    forEvents(events, (event) => {
      this._events[event] = this._events[event] || [];
      this._events[event].push(fct);
    });
  }
  off(events, fct) {
    var n = arguments.length;
    if (n === 0) {
      this._events = {};
      return;
    }
    forEvents(events, (event) => {
      if (n === 1)
        return delete this._events[event];
      if (event in this._events === false)
        return;
      this._events[event].splice(this._events[event].indexOf(fct), 1);
    });
  }
  trigger(events, ...args) {
    var self = this;
    forEvents(events, (event) => {
      if (event in self._events === false)
        return;
      for (let fct of self._events[event]) {
        fct.apply(self, args);
      }
    });
  }
};
function MicroPlugin(Interface) {
  Interface.plugins = {};
  return class extends Interface {
    constructor(...args) {
      super(...args);
      this.plugins = {
        names: [],
        settings: {},
        requested: {},
        loaded: {}
      };
    }
    static define(name, fn) {
      Interface.plugins[name] = {
        "name": name,
        "fn": fn
      };
    }
    initializePlugins(plugins) {
      var key, name;
      const self = this;
      const queue = [];
      if (Array.isArray(plugins)) {
        plugins.forEach((plugin) => {
          if (typeof plugin === "string") {
            queue.push(plugin);
          } else {
            self.plugins.settings[plugin.name] = plugin.options;
            queue.push(plugin.name);
          }
        });
      } else if (plugins) {
        for (key in plugins) {
          if (plugins.hasOwnProperty(key)) {
            self.plugins.settings[key] = plugins[key];
            queue.push(key);
          }
        }
      }
      while (name = queue.shift()) {
        self.require(name);
      }
    }
    loadPlugin(name) {
      var self = this;
      var plugins = self.plugins;
      var plugin = Interface.plugins[name];
      if (!Interface.plugins.hasOwnProperty(name)) {
        throw new Error('Unable to find "' + name + '" plugin');
      }
      plugins.requested[name] = true;
      plugins.loaded[name] = plugin.fn.apply(self, [self.plugins.settings[name] || {}]);
      plugins.names.push(name);
    }
    require(name) {
      var self = this;
      var plugins = self.plugins;
      if (!self.plugins.loaded.hasOwnProperty(name)) {
        if (plugins.requested[name]) {
          throw new Error('Plugin has circular dependency ("' + name + '")');
        }
        self.loadPlugin(name);
      }
      return plugins.loaded[name];
    }
  };
}
var latin_pat;
var accent_pat = "[\u0300-\u036F\xB7\u02BE]";
var accent_reg = new RegExp(accent_pat, "g");
var diacritic_patterns;
var latin_convert = {
  "\xE6": "ae",
  "\u2C65": "a",
  "\xF8": "o"
};
var convert_pat = new RegExp(Object.keys(latin_convert).join("|"), "g");
var code_points = [[67, 67], [160, 160], [192, 438], [452, 652], [961, 961], [1019, 1019], [1083, 1083], [1281, 1289], [1984, 1984], [5095, 5095], [7429, 7441], [7545, 7549], [7680, 7935], [8580, 8580], [9398, 9449], [11360, 11391], [42792, 42793], [42802, 42851], [42873, 42897], [42912, 42922], [64256, 64260], [65313, 65338], [65345, 65370]];
var asciifold = (str) => {
  return str.normalize("NFKD").replace(accent_reg, "").toLowerCase().replace(convert_pat, function(foreignletter) {
    return latin_convert[foreignletter];
  });
};
var arrayToPattern = (chars, glue = "|") => {
  if (chars.length > 1) {
    return "(?:" + chars.join(glue) + ")";
  }
  return chars[0];
};
var allSubstrings = (input) => {
  if (input.length === 1)
    return [[input]];
  var result = [];
  allSubstrings(input.substring(1)).forEach(function(subresult) {
    var tmp = subresult.slice(0);
    tmp[0] = input.charAt(0) + tmp[0];
    result.push(tmp);
    tmp = subresult.slice(0);
    tmp.unshift(input.charAt(0));
    result.push(tmp);
  });
  return result;
};
var generateDiacritics = () => {
  var diacritics = {};
  code_points.forEach((code_range) => {
    for (let i = code_range[0]; i <= code_range[1]; i++) {
      let diacritic = String.fromCharCode(i);
      let latin = asciifold(diacritic);
      if (latin == diacritic.toLowerCase()) {
        continue;
      }
      if (!(latin in diacritics)) {
        diacritics[latin] = [latin];
      }
      diacritics[latin].push(diacritic);
    }
  });
  var latin_chars = Object.keys(diacritics);
  latin_chars = latin_chars.sort((a, b) => b.length - a.length);
  latin_pat = new RegExp("(" + arrayToPattern(latin_chars) + accent_pat + "*)", "g");
  var diacritic_patterns2 = {};
  latin_chars.sort((a, b) => a.length - b.length).forEach((latin) => {
    var substrings = allSubstrings(latin);
    var pattern = substrings.map((sub_pat) => {
      sub_pat = sub_pat.map((l) => {
        if (diacritics.hasOwnProperty(l)) {
          return arrayToPattern(diacritics[l]);
        }
        return l;
      });
      return arrayToPattern(sub_pat, "");
    });
    diacritic_patterns2[latin] = arrayToPattern(pattern);
  });
  return diacritic_patterns2;
};
var diacriticRegexPoints = (regex) => {
  if (diacritic_patterns === void 0) {
    diacritic_patterns = generateDiacritics();
  }
  const decomposed = regex.normalize("NFKD").toLowerCase();
  return decomposed.split(latin_pat).map((part) => {
    if (part == "") {
      return "";
    }
    const no_accent = asciifold(part);
    if (diacritic_patterns.hasOwnProperty(no_accent)) {
      return diacritic_patterns[no_accent];
    }
    const composed_part = part.normalize("NFC");
    if (composed_part != part) {
      return arrayToPattern([part, composed_part]);
    }
    return part;
  }).join("");
};
var getAttr = (obj, name) => {
  if (!obj)
    return;
  return obj[name];
};
var getAttrNesting = (obj, name) => {
  if (!obj)
    return;
  var part, names = name.split(".");
  while ((part = names.shift()) && (obj = obj[part]))
    ;
  return obj;
};
var scoreValue = (value, token, weight) => {
  var score, pos;
  if (!value)
    return 0;
  value = value + "";
  pos = value.search(token.regex);
  if (pos === -1)
    return 0;
  score = token.string.length / value.length;
  if (pos === 0)
    score += 0.5;
  return score * weight;
};
var escape_regex = (str) => {
  return (str + "").replace(/([\$\(-\+\.\?\[-\^\{-\}])/g, "\\$1");
};
var propToArray = (obj, key) => {
  var value = obj[key];
  if (value && !Array.isArray(value)) {
    obj[key] = [value];
  }
};
var iterate = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};
var cmp = (a, b) => {
  if (typeof a === "number" && typeof b === "number") {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  a = asciifold(a + "").toLowerCase();
  b = asciifold(b + "").toLowerCase();
  if (a > b)
    return 1;
  if (b > a)
    return -1;
  return 0;
};
var Sifter = class {
  constructor(items, settings) {
    this.items = items;
    this.settings = settings || {
      diacritics: true
    };
  }
  tokenize(query, respect_word_boundaries, weights) {
    if (!query || !query.length)
      return [];
    const tokens = [];
    const words = query.split(/\s+/);
    var field_regex;
    if (weights) {
      field_regex = new RegExp("^(" + Object.keys(weights).map(escape_regex).join("|") + "):(.*)$");
    }
    words.forEach((word) => {
      let field_match;
      let field = null;
      let regex = null;
      if (field_regex && (field_match = word.match(field_regex))) {
        field = field_match[1];
        word = field_match[2];
      }
      if (word.length > 0) {
        regex = escape_regex(word);
        if (this.settings.diacritics) {
          regex = diacriticRegexPoints(regex);
        }
        if (respect_word_boundaries)
          regex = "\\b" + regex;
      }
      tokens.push({
        string: word,
        regex: regex ? new RegExp(regex, "iu") : null,
        field
      });
    });
    return tokens;
  }
  getScoreFunction(query, options) {
    var search = this.prepareSearch(query, options);
    return this._getScoreFunction(search);
  }
  _getScoreFunction(search) {
    const tokens = search.tokens, token_count = tokens.length;
    if (!token_count) {
      return function() {
        return 0;
      };
    }
    const fields = search.options.fields, weights = search.weights, field_count = fields.length, getAttrFn = search.getAttrFn;
    if (!field_count) {
      return function() {
        return 1;
      };
    }
    const scoreObject = function() {
      if (field_count === 1) {
        return function(token, data) {
          const field = fields[0].field;
          return scoreValue(getAttrFn(data, field), token, weights[field]);
        };
      }
      return function(token, data) {
        var sum = 0;
        if (token.field) {
          const value = getAttrFn(data, token.field);
          if (!token.regex && value) {
            sum += 1 / field_count;
          } else {
            sum += scoreValue(value, token, 1);
          }
        } else {
          iterate(weights, (weight, field) => {
            sum += scoreValue(getAttrFn(data, field), token, weight);
          });
        }
        return sum / field_count;
      };
    }();
    if (token_count === 1) {
      return function(data) {
        return scoreObject(tokens[0], data);
      };
    }
    if (search.options.conjunction === "and") {
      return function(data) {
        var i = 0, score, sum = 0;
        for (; i < token_count; i++) {
          score = scoreObject(tokens[i], data);
          if (score <= 0)
            return 0;
          sum += score;
        }
        return sum / token_count;
      };
    } else {
      return function(data) {
        var sum = 0;
        iterate(tokens, (token) => {
          sum += scoreObject(token, data);
        });
        return sum / token_count;
      };
    }
  }
  getSortFunction(query, options) {
    var search = this.prepareSearch(query, options);
    return this._getSortFunction(search);
  }
  _getSortFunction(search) {
    var i, n, implicit_score;
    const self = this, options = search.options, sort = !search.query && options.sort_empty ? options.sort_empty : options.sort, sort_flds = [], multipliers = [];
    const get_field = function get_field2(name, result) {
      if (name === "$score")
        return result.score;
      return search.getAttrFn(self.items[result.id], name);
    };
    if (sort) {
      for (i = 0, n = sort.length; i < n; i++) {
        if (search.query || sort[i].field !== "$score") {
          sort_flds.push(sort[i]);
        }
      }
    }
    if (search.query) {
      implicit_score = true;
      for (i = 0, n = sort_flds.length; i < n; i++) {
        if (sort_flds[i].field === "$score") {
          implicit_score = false;
          break;
        }
      }
      if (implicit_score) {
        sort_flds.unshift({
          field: "$score",
          direction: "desc"
        });
      }
    } else {
      for (i = 0, n = sort_flds.length; i < n; i++) {
        if (sort_flds[i].field === "$score") {
          sort_flds.splice(i, 1);
          break;
        }
      }
    }
    for (i = 0, n = sort_flds.length; i < n; i++) {
      multipliers.push(sort_flds[i].direction === "desc" ? -1 : 1);
    }
    const sort_flds_count = sort_flds.length;
    if (!sort_flds_count) {
      return null;
    } else if (sort_flds_count === 1) {
      const sort_fld = sort_flds[0].field;
      const multiplier = multipliers[0];
      return function(a, b) {
        return multiplier * cmp(get_field(sort_fld, a), get_field(sort_fld, b));
      };
    } else {
      return function(a, b) {
        var i2, result, field;
        for (i2 = 0; i2 < sort_flds_count; i2++) {
          field = sort_flds[i2].field;
          result = multipliers[i2] * cmp(get_field(field, a), get_field(field, b));
          if (result)
            return result;
        }
        return 0;
      };
    }
  }
  prepareSearch(query, optsUser) {
    const weights = {};
    var options = Object.assign({}, optsUser);
    propToArray(options, "sort");
    propToArray(options, "sort_empty");
    if (options.fields) {
      propToArray(options, "fields");
      const fields = [];
      options.fields.forEach((field) => {
        if (typeof field == "string") {
          field = {
            field,
            weight: 1
          };
        }
        fields.push(field);
        weights[field.field] = "weight" in field ? field.weight : 1;
      });
      options.fields = fields;
    }
    return {
      options,
      query: query.toLowerCase().trim(),
      tokens: this.tokenize(query, options.respect_word_boundaries, weights),
      total: 0,
      items: [],
      weights,
      getAttrFn: options.nesting ? getAttrNesting : getAttr
    };
  }
  search(query, options) {
    var self = this, score, search;
    search = this.prepareSearch(query, options);
    options = search.options;
    query = search.query;
    const fn_score = options.score || self._getScoreFunction(search);
    if (query.length) {
      iterate(self.items, (item, id) => {
        score = fn_score(item);
        if (options.filter === false || score > 0) {
          search.items.push({
            "score": score,
            "id": id
          });
        }
      });
    } else {
      iterate(self.items, (item, id) => {
        search.items.push({
          "score": 1,
          "id": id
        });
      });
    }
    const fn_sort = self._getSortFunction(search);
    if (fn_sort)
      search.items.sort(fn_sort);
    search.total = search.items.length;
    if (typeof options.limit === "number") {
      search.items = search.items.slice(0, options.limit);
    }
    return search;
  }
};
var getDom = (query) => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (query.indexOf("<") > -1) {
    let div = document.createElement("div");
    div.innerHTML = query.trim();
    return div.firstChild;
  }
  return document.querySelector(query);
};
var escapeQuery = (query) => {
  return query.replace(/['"\\]/g, "\\$&");
};
var triggerEvent = (dom_el, event_name) => {
  var event = document.createEvent("HTMLEvents");
  event.initEvent(event_name, true, false);
  dom_el.dispatchEvent(event);
};
var applyCSS = (dom_el, css) => {
  Object.assign(dom_el.style, css);
};
var addClasses = (elmts, ...classes) => {
  var norm_classes = classesArray(classes);
  elmts = castAsArray(elmts);
  elmts.map((el) => {
    norm_classes.map((cls) => {
      el.classList.add(cls);
    });
  });
};
var removeClasses = (elmts, ...classes) => {
  var norm_classes = classesArray(classes);
  elmts = castAsArray(elmts);
  elmts.map((el) => {
    norm_classes.map((cls) => {
      el.classList.remove(cls);
    });
  });
};
var classesArray = (args) => {
  var classes = [];
  for (let _classes of args) {
    if (typeof _classes === "string") {
      _classes = _classes.trim().split(/[\11\12\14\15\40]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  }
  return classes.filter(Boolean);
};
var castAsArray = (arg) => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};
var parentMatch = (target, selector, wrapper) => {
  if (wrapper && !wrapper.contains(target)) {
    return;
  }
  while (target && target.matches) {
    if (target.matches(selector)) {
      return target;
    }
    target = target.parentNode;
  }
};
var getTail = (list, direction = 0) => {
  if (direction > 0) {
    return list[list.length - 1];
  }
  return list[0];
};
var isEmptyObject = (obj) => {
  return Object.keys(obj).length === 0;
};
var nodeIndex = (el, amongst) => {
  if (!el)
    return -1;
  amongst = amongst || el.nodeName;
  var i = 0;
  while (el = el.previousElementSibling) {
    if (el.matches(amongst)) {
      i++;
    }
  }
  return i;
};
var setAttr = (el, attrs) => {
  for (const attr in attrs) {
    let val = attrs[attr];
    if (val == null) {
      el.removeAttribute(attr);
    } else {
      el.setAttribute(attr, "" + val);
    }
  }
};
var replaceNode = (existing, replacement) => {
  if (existing.parentNode)
    existing.parentNode.replaceChild(replacement, existing);
};
var highlight = (element, regex) => {
  if (regex === null)
    return;
  if (typeof regex === "string") {
    if (!regex.length)
      return;
    regex = new RegExp(regex, "i");
  }
  const highlightText = (node) => {
    var match = node.data.match(regex);
    if (match && node.data.length > 0) {
      var spannode = document.createElement("span");
      spannode.className = "highlight";
      var middlebit = node.splitText(match.index);
      middlebit.splitText(match[0].length);
      var middleclone = middlebit.cloneNode(true);
      spannode.appendChild(middleclone);
      replaceNode(middlebit, spannode);
      return 1;
    }
    return 0;
  };
  const highlightChildren = (node) => {
    if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== "highlight" || node.tagName !== "SPAN")) {
      for (var i = 0; i < node.childNodes.length; ++i) {
        i += highlightRecursive(node.childNodes[i]);
      }
    }
  };
  const highlightRecursive = (node) => {
    if (node.nodeType === 3) {
      return highlightText(node);
    }
    highlightChildren(node);
    return 0;
  };
  highlightRecursive(element);
};
var removeHighlight = (el) => {
  var elements = el.querySelectorAll("span.highlight");
  Array.prototype.forEach.call(elements, function(el2) {
    var parent = el2.parentNode;
    parent.replaceChild(el2.firstChild, el2);
    parent.normalize();
  });
};
var KEY_A = 65;
var KEY_RETURN = 13;
var KEY_ESC = 27;
var KEY_LEFT = 37;
var KEY_UP = 38;
var KEY_RIGHT = 39;
var KEY_DOWN = 40;
var KEY_BACKSPACE = 8;
var KEY_DELETE = 46;
var KEY_TAB = 9;
var IS_MAC = typeof navigator === "undefined" ? false : /Mac/.test(navigator.userAgent);
var KEY_SHORTCUT = IS_MAC ? "metaKey" : "ctrlKey";
var defaults = {
  options: [],
  optgroups: [],
  plugins: [],
  delimiter: ",",
  splitOn: null,
  persist: true,
  diacritics: true,
  create: null,
  createOnBlur: false,
  createFilter: null,
  highlight: true,
  openOnFocus: true,
  shouldOpen: null,
  maxOptions: 50,
  maxItems: null,
  hideSelected: null,
  duplicates: false,
  addPrecedence: false,
  selectOnTab: false,
  preload: null,
  allowEmptyOption: false,
  closeAfterSelect: false,
  loadThrottle: 300,
  loadingClass: "loading",
  dataAttr: null,
  optgroupField: "optgroup",
  valueField: "value",
  labelField: "text",
  disabledField: "disabled",
  optgroupLabelField: "label",
  optgroupValueField: "value",
  lockOptgroupOrder: false,
  sortField: "$order",
  searchField: ["text"],
  searchConjunction: "and",
  mode: null,
  wrapperClass: "ts-control",
  inputClass: "ts-input",
  dropdownClass: "ts-dropdown",
  dropdownContentClass: "ts-dropdown-content",
  itemClass: "item",
  optionClass: "option",
  dropdownParent: null,
  controlInput: null,
  copyClassesToDropdown: true,
  placeholder: null,
  hidePlaceholder: null,
  shouldLoad: function(query) {
    return query.length > 0;
  },
  render: {}
};
var hash_key = (value) => {
  if (typeof value === "undefined" || value === null)
    return null;
  return get_hash(value);
};
var get_hash = (value) => {
  if (typeof value === "boolean")
    return value ? "1" : "0";
  return value + "";
};
var escape_html = (str) => {
  return (str + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
};
var loadDebounce = (fn, delay) => {
  var timeout;
  return function(value, callback) {
    var self = this;
    if (timeout) {
      self.loading = Math.max(self.loading - 1, 0);
      clearTimeout(timeout);
    }
    timeout = setTimeout(function() {
      timeout = null;
      self.loadedSearches[value] = true;
      fn.call(self, value, callback);
    }, delay);
  };
};
var debounce_events = (self, types, fn) => {
  var type;
  var trigger = self.trigger;
  var event_args = {};
  self.trigger = function() {
    var type2 = arguments[0];
    if (types.indexOf(type2) !== -1) {
      event_args[type2] = arguments;
    } else {
      return trigger.apply(self, arguments);
    }
  };
  fn.apply(self, []);
  self.trigger = trigger;
  for (type in event_args) {
    trigger.apply(self, event_args[type]);
  }
};
var getSelection = (input) => {
  return {
    start: input.selectionStart || 0,
    length: (input.selectionEnd || 0) - (input.selectionStart || 0)
  };
};
var preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};
var addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};
var isKeyDown = (key_name, evt) => {
  if (!evt) {
    return false;
  }
  if (!evt[key_name]) {
    return false;
  }
  var count = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);
  if (count === 1) {
    return true;
  }
  return false;
};
var getId = (el, id) => {
  const existing_id = el.getAttribute("id");
  if (existing_id) {
    return existing_id;
  }
  el.setAttribute("id", id);
  return id;
};
var addSlashes = (str) => {
  return str.replace(/[\\"']/g, "\\$&");
};
var append = (parent, node) => {
  if (node)
    parent.append(node);
};
function getSettings(input, settings_user) {
  var settings = Object.assign({}, defaults, settings_user);
  var attr_data = settings.dataAttr;
  var field_label = settings.labelField;
  var field_value = settings.valueField;
  var field_disabled = settings.disabledField;
  var field_optgroup = settings.optgroupField;
  var field_optgroup_label = settings.optgroupLabelField;
  var field_optgroup_value = settings.optgroupValueField;
  var tag_name = input.tagName.toLowerCase();
  var placeholder = input.getAttribute("placeholder") || input.getAttribute("data-placeholder");
  if (!placeholder && !settings.allowEmptyOption) {
    let option = input.querySelector('option[value=""]');
    if (option) {
      placeholder = option.textContent;
    }
  }
  var settings_element = {
    placeholder,
    options: [],
    optgroups: [],
    items: [],
    maxItems: null
  };
  var init_select = () => {
    var tagName;
    var options = settings_element.options;
    var optionsMap = {};
    var group_count = 1;
    var readData = (el) => {
      var data = Object.assign({}, el.dataset);
      var json = attr_data && data[attr_data];
      if (typeof json === "string" && json.length) {
        data = Object.assign(data, JSON.parse(json));
      }
      return data;
    };
    var addOption = (option, group) => {
      var value = hash_key(option.value);
      if (value == null)
        return;
      if (!value && !settings.allowEmptyOption)
        return;
      if (optionsMap.hasOwnProperty(value)) {
        if (group) {
          var arr = optionsMap[value][field_optgroup];
          if (!arr) {
            optionsMap[value][field_optgroup] = group;
          } else if (!Array.isArray(arr)) {
            optionsMap[value][field_optgroup] = [arr, group];
          } else {
            arr.push(group);
          }
        }
      } else {
        var option_data = readData(option);
        option_data[field_label] = option_data[field_label] || option.textContent;
        option_data[field_value] = option_data[field_value] || value;
        option_data[field_disabled] = option_data[field_disabled] || option.disabled;
        option_data[field_optgroup] = option_data[field_optgroup] || group;
        option_data.$option = option;
        optionsMap[value] = option_data;
        options.push(option_data);
      }
      if (option.selected) {
        settings_element.items.push(value);
      }
    };
    var addGroup = (optgroup) => {
      var id, optgroup_data;
      optgroup_data = readData(optgroup);
      optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute("label") || "";
      optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;
      optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;
      settings_element.optgroups.push(optgroup_data);
      id = optgroup_data[field_optgroup_value];
      for (const option of optgroup.children) {
        addOption(option, id);
      }
    };
    settings_element.maxItems = input.hasAttribute("multiple") ? null : 1;
    for (const child of input.children) {
      tagName = child.tagName.toLowerCase();
      if (tagName === "optgroup") {
        addGroup(child);
      } else if (tagName === "option") {
        addOption(child);
      }
    }
  };
  var init_textbox = () => {
    const data_raw = input.getAttribute(attr_data);
    if (!data_raw) {
      var value = input.value.trim() || "";
      if (!settings.allowEmptyOption && !value.length)
        return;
      const values = value.split(settings.delimiter);
      for (const _value of values) {
        const option = {};
        option[field_label] = _value;
        option[field_value] = _value;
        settings_element.options.push(option);
      }
      settings_element.items = values;
    } else {
      settings_element.options = JSON.parse(data_raw);
      for (const opt of settings_element.options) {
        settings_element.items.push(opt[field_value]);
      }
    }
  };
  if (tag_name === "select") {
    init_select();
  } else {
    init_textbox();
  }
  return Object.assign({}, defaults, settings_element, settings_user);
}
var instance_i = 0;
var TomSelect = class extends MicroPlugin(MicroEvent) {
  constructor(input_arg, settings) {
    super();
    this.order = 0;
    this.tab_key = false;
    this.isOpen = false;
    this.isDisabled = false;
    this.isInvalid = false;
    this.isLocked = false;
    this.isFocused = false;
    this.isInputHidden = false;
    this.isSetup = false;
    this.ignoreFocus = false;
    this.hasOptions = false;
    this.lastValue = "";
    this.caretPos = 0;
    this.loading = 0;
    this.loadedSearches = {};
    this.activeOption = null;
    this.activeItems = [];
    this.optgroups = {};
    this.options = {};
    this.userOptions = {};
    this.items = [];
    this.renderCache = {
      "item": {},
      "option": {}
    };
    instance_i++;
    var dir;
    var input = getDom(input_arg);
    var self = this;
    if (input.tomselect) {
      throw new Error("Tom Select already initialized on this element");
    }
    input.tomselect = this;
    var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
    dir = computedStyle.getPropertyValue("direction");
    this.settings = getSettings(input, settings);
    this.input = input;
    this.tabIndex = input.tabIndex || 0;
    this.is_select_tag = input.tagName.toLowerCase() === "select";
    this.rtl = /rtl/i.test(dir);
    this.inputId = getId(input, "tomselect-" + instance_i);
    this.isRequired = input.required;
    this.sifter = new Sifter(this.options, {
      diacritics: this.settings.diacritics
    });
    this.setupOptions(this.settings.options, this.settings.optgroups);
    delete this.settings.optgroups;
    delete this.settings.options;
    this.settings.mode = this.settings.mode || (this.settings.maxItems === 1 ? "single" : "multi");
    if (typeof this.settings.hideSelected !== "boolean") {
      this.settings.hideSelected = this.settings.mode === "multi";
    }
    if (typeof this.settings.hidePlaceholder !== "boolean") {
      this.settings.hidePlaceholder = this.settings.mode !== "multi";
    }
    var filter = this.settings.createFilter;
    if (typeof filter !== "function") {
      if (typeof filter === "string") {
        filter = new RegExp(filter);
      }
      if (filter instanceof RegExp) {
        this.settings.createFilter = (input2) => filter.test(input2);
      } else {
        this.settings.createFilter = () => true;
      }
    }
    this.initializePlugins(this.settings.plugins);
    this.setupCallbacks();
    this.setupTemplates();
    var settings = self.settings;
    var wrapper;
    var control;
    var control_input;
    var dropdown;
    var dropdown_content;
    var inputMode;
    var classes;
    var classes_plugins;
    var input = self.input;
    var control_id;
    const passive_event = {
      passive: true
    };
    const listboxId = self.inputId + "-ts-dropdown";
    inputMode = self.settings.mode;
    classes = input.getAttribute("class") || "";
    wrapper = getDom("<div>");
    addClasses(wrapper, settings.wrapperClass, classes, inputMode);
    control = getDom('<div class="items">');
    addClasses(control, settings.inputClass);
    append(wrapper, control);
    dropdown = self._render("dropdown");
    addClasses(dropdown, settings.dropdownClass, inputMode);
    dropdown_content = getDom(`<div role="listbox" id="${listboxId}" tabindex="-1">`);
    addClasses(dropdown_content, settings.dropdownContentClass);
    append(dropdown, dropdown_content);
    getDom(settings.dropdownParent || wrapper).appendChild(dropdown);
    if (settings.controlInput) {
      control_input = getDom(settings.controlInput);
    } else {
      control_input = getDom('<input type="text" autocomplete="off" size="1" />');
      var attrs = ["autocorrect", "autocapitalize", "autocomplete"];
      for (const attr of attrs) {
        if (input.getAttribute(attr)) {
          setAttr(control_input, {
            [attr]: input.getAttribute(attr)
          });
        }
      }
    }
    if (!settings.controlInput) {
      control_input.tabIndex = input.disabled ? -1 : self.tabIndex;
      control.appendChild(control_input);
    }
    setAttr(control_input, {
      role: "combobox",
      haspopup: "listbox",
      "aria-expanded": "false",
      "aria-controls": listboxId
    });
    control_id = getId(control_input, self.inputId + "-tomselected");
    let query = "label[for='" + escapeQuery(self.inputId) + "']";
    let label = document.querySelector(query);
    if (label) {
      setAttr(label, {
        for: control_id
      });
      let label_id = getId(label, self.inputId + "-ts-label");
      setAttr(dropdown_content, {
        "aria-labelledby": label_id
      });
    }
    if (self.settings.copyClassesToDropdown) {
      addClasses(dropdown, classes);
    }
    wrapper.style.width = input.style.width;
    if (self.plugins.names.length) {
      classes_plugins = "plugin-" + self.plugins.names.join(" plugin-");
      addClasses([wrapper, dropdown], classes_plugins);
    }
    if ((settings.maxItems === null || settings.maxItems > 1) && self.is_select_tag) {
      setAttr(input, {
        multiple: "multiple"
      });
    }
    if (self.settings.placeholder) {
      setAttr(control_input, {
        placeholder: settings.placeholder
      });
    }
    if (!self.settings.splitOn && self.settings.delimiter) {
      self.settings.splitOn = new RegExp("\\s*" + escape_regex(self.settings.delimiter) + "+\\s*");
    }
    if (this.settings.load && this.settings.loadThrottle) {
      this.settings.load = loadDebounce(this.settings.load, this.settings.loadThrottle);
    }
    this.control = control;
    this.control_input = control_input;
    this.wrapper = wrapper;
    this.dropdown = dropdown;
    this.dropdown_content = dropdown_content;
    self.control_input.type = input.type;
    addEvent(dropdown, "click", (evt) => {
      const option = parentMatch(evt.target, "[data-selectable]");
      if (option) {
        self.onOptionSelect(evt, option);
        preventDefault(evt, true);
      }
    });
    addEvent(control, "click", (evt) => {
      var target_match = parentMatch(evt.target, "." + self.settings.itemClass, control);
      if (target_match && self.onItemSelect(evt, target_match)) {
        preventDefault(evt, true);
        return;
      }
      if (control_input.value != "") {
        return;
      }
      self.onClick();
      preventDefault(evt, true);
    });
    addEvent(control_input, "mousedown", (e) => {
      if (control_input.value !== "") {
        e.stopPropagation();
      }
    });
    addEvent(control_input, "keydown", (e) => self.onKeyDown(e));
    addEvent(control_input, "keyup", (e) => self.onKeyUp(e));
    addEvent(control_input, "keypress", (e) => self.onKeyPress(e));
    addEvent(control_input, "resize", () => self.positionDropdown(), passive_event);
    addEvent(control_input, "blur", () => self.onBlur());
    addEvent(control_input, "focus", (e) => self.onFocus(e));
    addEvent(control_input, "paste", (e) => self.onPaste(e));
    const doc_mousedown = (evt) => {
      const target = evt.composedPath()[0];
      if (!wrapper.contains(target) && !dropdown.contains(target)) {
        if (self.isFocused) {
          self.blur();
        }
        self.inputState();
        return;
      }
      preventDefault(evt, true);
    };
    var win_scroll = () => {
      if (self.isOpen) {
        self.positionDropdown();
      }
    };
    addEvent(document, "mousedown", doc_mousedown);
    addEvent(window, "sroll", win_scroll, passive_event);
    addEvent(window, "resize", win_scroll, passive_event);
    this._destroy = () => {
      document.removeEventListener("mousedown", doc_mousedown);
      window.removeEventListener("sroll", win_scroll);
      window.removeEventListener("resize", win_scroll);
    };
    this.revertSettings = {
      innerHTML: input.innerHTML,
      tabIndex: input.tabIndex
    };
    input.tabIndex = -1;
    setAttr(input, {
      hidden: "hidden"
    });
    input.insertAdjacentElement("afterend", self.wrapper);
    self.setValue(settings.items);
    settings.items = [];
    addEvent(input, "invalid", (e) => {
      preventDefault(e);
      if (!self.isInvalid) {
        self.isInvalid = true;
        self.refreshState();
      }
    });
    self.updateOriginalInput();
    self.refreshItems();
    self.close(false);
    self.inputState();
    self.isSetup = true;
    if (input.disabled) {
      self.disable();
    }
    self.on("change", this.onChange);
    addClasses(input, "tomselected");
    self.trigger("initialize");
    if (settings.preload === true) {
      self.load("");
    }
    self.setup();
  }
  setup() {
  }
  setupOptions(options = [], optgroups = []) {
    for (const option of options) {
      this.registerOption(option);
    }
    for (const optgroup of optgroups) {
      this.registerOptionGroup(optgroup);
    }
  }
  setupTemplates() {
    var self = this;
    var field_label = self.settings.labelField;
    var field_optgroup = self.settings.optgroupLabelField;
    var templates = {
      "optgroup": (data) => {
        let optgroup = document.createElement("div");
        optgroup.className = "optgroup";
        optgroup.appendChild(data.options);
        return optgroup;
      },
      "optgroup_header": (data, escape) => {
        return '<div class="optgroup-header">' + escape(data[field_optgroup]) + "</div>";
      },
      "option": (data, escape) => {
        return "<div>" + escape(data[field_label]) + "</div>";
      },
      "item": (data, escape) => {
        return "<div>" + escape(data[field_label]) + "</div>";
      },
      "option_create": (data, escape) => {
        return '<div class="create">Add <strong>' + escape(data.input) + "</strong>&hellip;</div>";
      },
      "no_results": () => {
        return '<div class="no-results">No results found</div>';
      },
      "loading": () => {
        return '<div class="spinner"></div>';
      },
      "not_loading": () => {
      },
      "dropdown": () => {
        return "<div></div>";
      }
    };
    self.settings.render = Object.assign({}, templates, self.settings.render);
  }
  setupCallbacks() {
    var key, fn;
    var callbacks = {
      "initialize": "onInitialize",
      "change": "onChange",
      "item_add": "onItemAdd",
      "item_remove": "onItemRemove",
      "item_select": "onItemSelect",
      "clear": "onClear",
      "option_add": "onOptionAdd",
      "option_remove": "onOptionRemove",
      "option_clear": "onOptionClear",
      "optgroup_add": "onOptionGroupAdd",
      "optgroup_remove": "onOptionGroupRemove",
      "optgroup_clear": "onOptionGroupClear",
      "dropdown_open": "onDropdownOpen",
      "dropdown_close": "onDropdownClose",
      "type": "onType",
      "load": "onLoad",
      "focus": "onFocus",
      "blur": "onBlur"
    };
    for (key in callbacks) {
      fn = this.settings[callbacks[key]];
      if (fn)
        this.on(key, fn);
    }
  }
  onClick() {
    var self = this;
    if (self.activeItems.length > 0) {
      self.clearActiveItems();
      self.focus();
      return;
    }
    if (self.isFocused && self.isOpen) {
      self.blur();
    } else {
      self.focus();
    }
  }
  onMouseDown() {
  }
  onChange() {
    triggerEvent(this.input, "input");
    triggerEvent(this.input, "change");
  }
  onPaste(e) {
    var self = this;
    if (self.isFull() || self.isInputHidden || self.isLocked) {
      preventDefault(e);
      return;
    }
    if (self.settings.splitOn) {
      setTimeout(() => {
        var pastedText = self.inputValue();
        if (!pastedText.match(self.settings.splitOn)) {
          return;
        }
        var splitInput = pastedText.trim().split(self.settings.splitOn);
        for (const piece of splitInput) {
          self.createItem(piece);
        }
      }, 0);
    }
  }
  onKeyPress(e) {
    var self = this;
    if (self.isLocked) {
      preventDefault(e);
      return;
    }
    var character = String.fromCharCode(e.keyCode || e.which);
    if (self.settings.create && self.settings.mode === "multi" && character === self.settings.delimiter) {
      self.createItem();
      preventDefault(e);
      return;
    }
  }
  onKeyDown(e) {
    var self = this;
    if (self.isLocked) {
      if (e.keyCode !== KEY_TAB) {
        preventDefault(e);
      }
      return;
    }
    switch (e.keyCode) {
      case KEY_A:
        if (isKeyDown(KEY_SHORTCUT, e)) {
          self.selectAll();
          return;
        }
        break;
      case KEY_ESC:
        if (self.isOpen) {
          preventDefault(e, true);
          self.close();
        }
        self.clearActiveItems();
        return;
      case KEY_DOWN:
        if (!self.isOpen && self.hasOptions) {
          self.open();
        } else if (self.activeOption) {
          let next = self.getAdjacent(self.activeOption, 1);
          if (next)
            self.setActiveOption(next);
        }
        preventDefault(e);
        return;
      case KEY_UP:
        if (self.activeOption) {
          let prev = self.getAdjacent(self.activeOption, -1);
          if (prev)
            self.setActiveOption(prev);
        }
        preventDefault(e);
        return;
      case KEY_RETURN:
        if (self.isOpen && self.activeOption) {
          self.onOptionSelect(e, self.activeOption);
          preventDefault(e);
        } else if (self.settings.create && self.createItem()) {
          preventDefault(e);
        }
        return;
      case KEY_LEFT:
        self.advanceSelection(-1, e);
        return;
      case KEY_RIGHT:
        self.advanceSelection(1, e);
        return;
      case KEY_TAB:
        if (self.settings.selectOnTab) {
          if (self.isOpen && self.activeOption) {
            self.tab_key = true;
            self.onOptionSelect(e, self.activeOption);
            preventDefault(e);
            self.tab_key = false;
          }
          if (self.settings.create && self.createItem()) {
            preventDefault(e);
          }
        }
        return;
      case KEY_BACKSPACE:
      case KEY_DELETE:
        self.deleteSelection(e);
        return;
    }
    if (self.isInputHidden && !isKeyDown(KEY_SHORTCUT, e)) {
      preventDefault(e);
    }
  }
  onKeyUp(e) {
    var self = this;
    if (self.isLocked) {
      preventDefault(e);
      return;
    }
    var value = self.inputValue();
    if (self.lastValue !== value) {
      self.lastValue = value;
      if (self.settings.shouldLoad.call(self, value)) {
        self.load(value);
      }
      self.refreshOptions();
      self.trigger("type", value);
    }
  }
  onFocus(e) {
    var self = this;
    var wasFocused = self.isFocused;
    if (self.isDisabled) {
      self.blur();
      preventDefault(e);
      return;
    }
    if (self.ignoreFocus)
      return;
    self.isFocused = true;
    if (self.settings.preload === "focus")
      self.load("");
    if (!wasFocused)
      self.trigger("focus");
    if (!self.activeItems.length) {
      self.showInput();
      self.refreshOptions(!!self.settings.openOnFocus);
    }
    self.refreshState();
  }
  onBlur() {
    var self = this;
    if (!self.isFocused)
      return;
    self.isFocused = false;
    self.ignoreFocus = false;
    var deactivate = () => {
      self.close();
      self.setActiveItem();
      self.setCaret(self.items.length);
      self.trigger("blur");
    };
    if (self.settings.create && self.settings.createOnBlur) {
      self.createItem(null, false, deactivate);
    } else {
      deactivate();
    }
  }
  onOptionSelect(evt, option) {
    var value, self = this;
    if (!option) {
      return;
    }
    if (option.parentElement && option.parentElement.matches("[data-disabled]")) {
      return;
    }
    if (option.classList.contains("create")) {
      self.createItem(null, true, () => {
        if (self.settings.closeAfterSelect) {
          self.close();
        }
      });
    } else {
      value = option.dataset.value;
      if (typeof value !== "undefined") {
        self.lastQuery = null;
        self.addItem(value);
        if (self.settings.closeAfterSelect) {
          self.close();
        }
        if (!self.settings.hideSelected && evt.type && /click/.test(evt.type)) {
          self.setActiveOption(option);
        }
      }
    }
  }
  onItemSelect(evt, item) {
    var self = this;
    if (!self.isLocked && self.settings.mode === "multi") {
      preventDefault(evt);
      self.setActiveItem(item, evt);
      return true;
    }
    return false;
  }
  canLoad(value) {
    if (!this.settings.load)
      return false;
    if (this.loadedSearches.hasOwnProperty(value))
      return false;
    return true;
  }
  load(value) {
    const self = this;
    if (!self.canLoad(value))
      return;
    addClasses(self.wrapper, self.settings.loadingClass);
    self.loading++;
    const callback = self.loadCallback.bind(self);
    self.settings.load.call(self, value, callback);
  }
  loadCallback(options, optgroups) {
    const self = this;
    self.loading = Math.max(self.loading - 1, 0);
    self.lastQuery = null;
    self.clearActiveOption();
    self.setupOptions(options, optgroups);
    self.refreshOptions(self.isFocused && !self.isInputHidden);
    if (!self.loading) {
      removeClasses(self.wrapper, self.settings.loadingClass);
    }
    self.trigger("load", options, optgroups);
  }
  setTextboxValue(value = "") {
    var input = this.control_input;
    var changed = input.value !== value;
    if (changed) {
      input.value = value;
      triggerEvent(input, "update");
      this.lastValue = value;
    }
  }
  getValue() {
    if (this.is_select_tag && this.input.hasAttribute("multiple")) {
      return this.items;
    }
    return this.items.join(this.settings.delimiter);
  }
  setValue(value, silent) {
    var events = silent ? [] : ["change"];
    debounce_events(this, events, () => {
      this.clear(silent);
      this.addItems(value, silent);
    });
  }
  setMaxItems(value) {
    if (value === 0)
      value = null;
    this.settings.maxItems = value;
    this.refreshState();
  }
  setActiveItem(item, e) {
    var self = this;
    var eventName;
    var i, begin, end, swap;
    var last;
    if (self.settings.mode === "single")
      return;
    if (!item) {
      self.clearActiveItems();
      if (self.isFocused) {
        self.showInput();
      }
      return;
    }
    eventName = e && e.type.toLowerCase();
    if (eventName === "click" && isKeyDown("shiftKey", e) && self.activeItems.length) {
      last = self.getLastActive();
      begin = Array.prototype.indexOf.call(self.control.children, last);
      end = Array.prototype.indexOf.call(self.control.children, item);
      if (begin > end) {
        swap = begin;
        begin = end;
        end = swap;
      }
      for (i = begin; i <= end; i++) {
        item = self.control.children[i];
        if (self.activeItems.indexOf(item) === -1) {
          self.setActiveItemClass(item);
        }
      }
      preventDefault(e);
    } else if (eventName === "click" && isKeyDown(KEY_SHORTCUT, e) || eventName === "keydown" && isKeyDown("shiftKey", e)) {
      if (item.classList.contains("active")) {
        self.removeActiveItem(item);
      } else {
        self.setActiveItemClass(item);
      }
    } else {
      self.clearActiveItems();
      self.setActiveItemClass(item);
    }
    self.hideInput();
    if (!self.isFocused) {
      self.focus();
    }
  }
  setActiveItemClass(item) {
    const self = this;
    const last_active = self.control.querySelector(".last-active");
    if (last_active)
      removeClasses(last_active, "last-active");
    addClasses(item, "active last-active");
    self.trigger("item_select", item);
    if (self.activeItems.indexOf(item) == -1) {
      self.activeItems.push(item);
    }
  }
  removeActiveItem(item) {
    var idx = this.activeItems.indexOf(item);
    this.activeItems.splice(idx, 1);
    removeClasses(item, "active");
  }
  clearActiveItems() {
    removeClasses(this.activeItems, "active");
    this.activeItems = [];
  }
  setActiveOption(option) {
    if (option === this.activeOption) {
      return;
    }
    this.clearActiveOption();
    if (!option)
      return;
    this.activeOption = option;
    setAttr(this.control_input, {
      "aria-activedescendant": option.getAttribute("id")
    });
    setAttr(option, {
      "aria-selected": "true"
    });
    addClasses(option, "active");
    this.scrollToOption(option);
  }
  scrollToOption(option, behavior) {
    if (!option)
      return;
    const content = this.dropdown_content;
    const height_menu = content.clientHeight;
    const scrollTop = content.scrollTop || 0;
    const height_item = option.offsetHeight;
    const y = option.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;
    if (y + height_item > height_menu + scrollTop) {
      this.scroll(y - height_menu + height_item, behavior);
    } else if (y < scrollTop) {
      this.scroll(y, behavior);
    }
  }
  scroll(scrollTop, behavior) {
    const content = this.dropdown_content;
    if (behavior) {
      content.style.scrollBehavior = behavior;
    }
    content.scrollTop = scrollTop;
    content.style.scrollBehavior = "";
  }
  clearActiveOption() {
    if (this.activeOption) {
      removeClasses(this.activeOption, "active");
      setAttr(this.activeOption, {
        "aria-selected": null
      });
    }
    this.activeOption = null;
    setAttr(this.control_input, {
      "aria-activedescendant": null
    });
  }
  selectAll() {
    if (this.settings.mode === "single")
      return;
    this.activeItems = this.controlChildren();
    if (this.activeItems.length) {
      addClasses(this.activeItems, "active");
      this.hideInput();
      this.close();
    }
    this.focus();
  }
  inputState() {
    var self = this;
    if (self.settings.controlInput)
      return;
    if (self.activeItems.length > 0 || !self.isFocused && this.settings.hidePlaceholder && self.items.length > 0) {
      self.setTextboxValue();
      self.isInputHidden = true;
      addClasses(self.wrapper, "input-hidden");
    } else {
      self.isInputHidden = false;
      removeClasses(self.wrapper, "input-hidden");
    }
  }
  hideInput() {
    this.inputState();
  }
  showInput() {
    this.inputState();
  }
  inputValue() {
    return this.control_input.value.trim();
  }
  focus() {
    var self = this;
    if (self.isDisabled)
      return;
    self.ignoreFocus = true;
    self.control_input.focus();
    setTimeout(() => {
      self.ignoreFocus = false;
      self.onFocus();
    }, 0);
  }
  blur() {
    this.control_input.blur();
    this.onBlur();
  }
  getScoreFunction(query) {
    return this.sifter.getScoreFunction(query, this.getSearchOptions());
  }
  getSearchOptions() {
    var settings = this.settings;
    var sort = settings.sortField;
    if (typeof settings.sortField === "string") {
      sort = [{
        field: settings.sortField
      }];
    }
    return {
      fields: settings.searchField,
      conjunction: settings.searchConjunction,
      sort,
      nesting: settings.nesting
    };
  }
  search(query) {
    var i, result, calculateScore;
    var self = this;
    var options = this.getSearchOptions();
    if (self.settings.score) {
      calculateScore = self.settings.score.call(self, query);
      if (typeof calculateScore !== "function") {
        throw new Error('Tom Select "score" setting must be a function that returns a function');
      }
    }
    if (query !== self.lastQuery) {
      self.lastQuery = query;
      result = self.sifter.search(query, Object.assign(options, {
        score: calculateScore
      }));
      self.currentResults = result;
    } else {
      result = Object.assign({}, self.currentResults);
    }
    if (self.settings.hideSelected) {
      for (i = result.items.length - 1; i >= 0; i--) {
        let hashed = hash_key(result.items[i].id);
        if (hashed && self.items.indexOf(hashed) !== -1) {
          result.items.splice(i, 1);
        }
      }
    }
    return result;
  }
  refreshOptions(triggerDropdown = true) {
    var i, j, k, n, optgroup, optgroups, html, has_create_option, active_value, active_group;
    var create;
    const groups = {};
    const groups_order = [];
    var self = this;
    var query = self.inputValue();
    var results = self.search(query);
    var active_option = self.activeOption;
    var show_dropdown = self.settings.shouldOpen || false;
    var dropdown_content = self.dropdown_content;
    if (active_option) {
      active_value = active_option.dataset.value;
      active_group = active_option.closest("[data-group]");
    }
    n = results.items.length;
    if (typeof self.settings.maxOptions === "number") {
      n = Math.min(n, self.settings.maxOptions);
    }
    if (n > 0) {
      show_dropdown = true;
    }
    for (i = 0; i < n; i++) {
      let opt_value = results.items[i].id;
      let option = self.options[opt_value];
      let option_el = self.getOption(opt_value, true);
      if (!self.settings.hideSelected) {
        option_el.classList.toggle("selected", self.items.includes(opt_value));
      }
      optgroup = option[self.settings.optgroupField] || "";
      optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];
      for (j = 0, k = optgroups && optgroups.length; j < k; j++) {
        optgroup = optgroups[j];
        if (!self.optgroups.hasOwnProperty(optgroup)) {
          optgroup = "";
        }
        if (!groups.hasOwnProperty(optgroup)) {
          groups[optgroup] = document.createDocumentFragment();
          groups_order.push(optgroup);
        }
        if (j > 0) {
          option_el = option_el.cloneNode(true);
          setAttr(option_el, {
            id: option.$id + "-clone-" + j,
            "aria-selected": null
          });
          option_el.classList.add("ts-cloned");
          removeClasses(option_el, "active");
        }
        if (active_value == opt_value && active_group && active_group.dataset.group === optgroup) {
          active_option = option_el;
        }
        groups[optgroup].appendChild(option_el);
      }
    }
    if (this.settings.lockOptgroupOrder) {
      groups_order.sort((a, b) => {
        var a_order = self.optgroups[a] && self.optgroups[a].$order || 0;
        var b_order = self.optgroups[b] && self.optgroups[b].$order || 0;
        return a_order - b_order;
      });
    }
    html = document.createDocumentFragment();
    for (optgroup of groups_order) {
      if (self.optgroups.hasOwnProperty(optgroup) && groups[optgroup].children.length) {
        let group_options = document.createDocumentFragment();
        let header = self.render("optgroup_header", self.optgroups[optgroup]);
        append(group_options, header);
        append(group_options, groups[optgroup]);
        let group_html = self.render("optgroup", {
          group: self.optgroups[optgroup],
          options: group_options
        });
        append(html, group_html);
      } else {
        append(html, groups[optgroup]);
      }
    }
    dropdown_content.innerHTML = "";
    append(dropdown_content, html);
    if (self.settings.highlight) {
      removeHighlight(dropdown_content);
      if (results.query.length && results.tokens.length) {
        for (const tok of results.tokens) {
          highlight(dropdown_content, tok.regex);
        }
      }
    }
    var add_template = (template) => {
      let content = self.render(template, {
        input: query
      });
      if (content) {
        show_dropdown = true;
        dropdown_content.insertBefore(content, dropdown_content.firstChild);
      }
      return content;
    };
    if (!self.settings.shouldLoad.call(self, query)) {
      add_template("not_loading");
    } else if (self.loading) {
      add_template("loading");
    } else if (results.items.length === 0) {
      add_template("no_results");
    }
    has_create_option = self.canCreate(query);
    if (has_create_option) {
      create = add_template("option_create");
    }
    self.hasOptions = results.items.length > 0 || has_create_option;
    if (show_dropdown) {
      if (results.items.length > 0) {
        if (!dropdown_content.contains(active_option) && self.settings.mode === "single" && self.items.length) {
          active_option = self.getOption(self.items[0]);
        }
        if (!dropdown_content.contains(active_option)) {
          let active_index = 0;
          if (create && !self.settings.addPrecedence) {
            active_index = 1;
          }
          active_option = self.selectable()[active_index];
        }
      } else if (create) {
        active_option = create;
      }
      if (triggerDropdown && !self.isOpen) {
        self.open();
        self.scrollToOption(active_option, "auto");
      }
      self.setActiveOption(active_option);
    } else {
      self.clearActiveOption();
      if (triggerDropdown && self.isOpen) {
        self.close(false);
      }
    }
  }
  selectable() {
    return this.dropdown_content.querySelectorAll("[data-selectable]");
  }
  addOption(data) {
    var value, self = this;
    if (Array.isArray(data)) {
      for (const dat of data) {
        self.addOption(dat);
      }
      return;
    }
    if (value = self.registerOption(data)) {
      self.userOptions[value] = true;
      self.lastQuery = null;
      self.trigger("option_add", value, data);
    }
  }
  registerOption(data) {
    var key = hash_key(data[this.settings.valueField]);
    if (key === null || this.options.hasOwnProperty(key))
      return false;
    data.$order = data.$order || ++this.order;
    data.$id = this.inputId + "-opt-" + data.$order;
    this.options[key] = data;
    return key;
  }
  registerOptionGroup(data) {
    var key = hash_key(data[this.settings.optgroupValueField]);
    if (key === null)
      return false;
    data.$order = data.$order || ++this.order;
    this.optgroups[key] = data;
    return key;
  }
  addOptionGroup(id, data) {
    var hashed_id;
    data[this.settings.optgroupValueField] = id;
    if (hashed_id = this.registerOptionGroup(data)) {
      this.trigger("optgroup_add", hashed_id, data);
    }
  }
  removeOptionGroup(id) {
    if (this.optgroups.hasOwnProperty(id)) {
      delete this.optgroups[id];
      this.clearCache();
      this.trigger("optgroup_remove", id);
    }
  }
  clearOptionGroups() {
    this.optgroups = {};
    this.clearCache();
    this.trigger("optgroup_clear");
  }
  updateOption(value, data) {
    const self = this;
    var item_new;
    var index_item;
    const hashed = hash_key(value);
    if (hashed === null)
      return;
    const value_new = hash_key(data[self.settings.valueField]);
    const option = self.getOption(hashed);
    const item = self.getItem(hashed);
    if (!self.options.hasOwnProperty(hashed))
      return;
    if (typeof value_new !== "string")
      throw new Error("Value must be set in option data");
    data.$order = data.$order || self.options[hashed].$order;
    delete self.options[hashed];
    self.uncacheValue(value_new);
    self.uncacheValue(hashed, false);
    self.options[value_new] = data;
    if (option) {
      if (self.dropdown_content.contains(option)) {
        const option_new = self._render("option", data);
        replaceNode(option, option_new);
        if (self.activeOption === option) {
          self.setActiveOption(option_new);
        }
      }
      option.remove();
    }
    if (item) {
      index_item = self.items.indexOf(hashed);
      if (index_item !== -1) {
        self.items.splice(index_item, 1, value_new);
      }
      item_new = self._render("item", data);
      if (item.classList.contains("active"))
        addClasses(item_new, "active");
      replaceNode(item, item_new);
    }
    self.lastQuery = null;
  }
  removeOption(value, silent) {
    const self = this;
    value = get_hash(value);
    self.uncacheValue(value);
    delete self.userOptions[value];
    delete self.options[value];
    self.lastQuery = null;
    self.trigger("option_remove", value);
    self.removeItem(value, silent);
  }
  clearOptions() {
    this.loadedSearches = {};
    this.userOptions = {};
    this.clearCache();
    var selected = {};
    for (let key in this.options) {
      if (this.options.hasOwnProperty(key) && this.items.indexOf(key) >= 0) {
        selected[key] = this.options[key];
      }
    }
    this.options = this.sifter.items = selected;
    this.lastQuery = null;
    this.trigger("option_clear");
  }
  uncacheValue(value, remove_node = true) {
    const self = this;
    const cache_items = self.renderCache["item"];
    const cache_options = self.renderCache["option"];
    if (cache_items)
      delete cache_items[value];
    if (cache_options)
      delete cache_options[value];
    if (remove_node) {
      const option_el = self.getOption(value);
      if (option_el)
        option_el.remove();
    }
  }
  getOption(value, create = false) {
    var hashed = hash_key(value);
    var option_el = this.rendered("option", hashed);
    if (!option_el && create && hashed !== null) {
      option_el = this._render("option", this.options[hashed]);
    }
    return option_el;
  }
  getAdjacent(option, direction, type = "option") {
    var self = this, all;
    if (!option) {
      return null;
    }
    if (type == "item") {
      all = self.controlChildren();
    } else {
      all = self.dropdown_content.querySelectorAll("[data-selectable]");
    }
    for (let i = 0; i < all.length; i++) {
      if (all[i] != option) {
        continue;
      }
      if (direction > 0) {
        return all[i + 1];
      }
      return all[i - 1];
    }
    return null;
  }
  getItem(item) {
    if (typeof item == "object") {
      return item;
    }
    var value = hash_key(item);
    return value !== null ? this.control.querySelector(`[data-value="${addSlashes(value)}"]`) : null;
  }
  addItems(values, silent) {
    var self = this;
    var items = Array.isArray(values) ? values : [values];
    items = items.filter((x) => self.items.indexOf(x) === -1);
    for (let i = 0, n = items.length; i < n; i++) {
      self.isPending = i < n - 1;
      self.addItem(items[i], silent);
    }
  }
  addItem(value, silent) {
    var events = silent ? [] : ["change"];
    debounce_events(this, events, () => {
      var item, wasFull;
      const self = this;
      const inputMode = self.settings.mode;
      const hashed = hash_key(value);
      if (hashed && self.items.indexOf(hashed) !== -1) {
        if (inputMode === "single") {
          self.close();
        }
        if (inputMode === "single" || !self.settings.duplicates) {
          return;
        }
      }
      if (hashed === null || !self.options.hasOwnProperty(hashed))
        return;
      if (inputMode === "single")
        self.clear(silent);
      if (inputMode === "multi" && self.isFull())
        return;
      item = self._render("item", self.options[hashed]);
      if (self.control.contains(item)) {
        item = item.cloneNode(true);
      }
      wasFull = self.isFull();
      self.items.splice(self.caretPos, 0, hashed);
      self.insertAtCaret(item);
      if (self.isSetup) {
        let options = self.selectable();
        if (!self.isPending && self.settings.hideSelected) {
          let option = self.getOption(hashed);
          let next = self.getAdjacent(option, 1);
          if (next) {
            self.setActiveOption(next);
          }
        }
        if (!self.isPending) {
          self.refreshOptions(self.isFocused && inputMode !== "single");
        }
        if (!options.length || self.isFull()) {
          self.close();
        } else if (!self.isPending) {
          self.positionDropdown();
        }
        self.trigger("item_add", hashed, item);
        if (!self.isPending) {
          self.updateOriginalInput({
            silent
          });
        }
      }
      if (!self.isPending || !wasFull && self.isFull()) {
        self.refreshState();
      }
    });
  }
  removeItem(item = null, silent) {
    const self = this;
    item = self.getItem(item);
    if (!item)
      return;
    var i, idx;
    const value = item.dataset.value;
    i = nodeIndex(item);
    item.remove();
    if (item.classList.contains("active")) {
      idx = self.activeItems.indexOf(item);
      self.activeItems.splice(idx, 1);
      removeClasses(item, "active");
    }
    self.items.splice(i, 1);
    self.lastQuery = null;
    if (!self.settings.persist && self.userOptions.hasOwnProperty(value)) {
      self.removeOption(value, silent);
    }
    if (i < self.caretPos) {
      self.setCaret(self.caretPos - 1);
    }
    self.updateOriginalInput({
      silent
    });
    self.refreshState();
    self.positionDropdown();
    self.trigger("item_remove", value, item);
  }
  createItem(input = null, triggerDropdown = true, callback = () => {
  }) {
    var self = this;
    var caret = self.caretPos;
    var output;
    input = input || self.inputValue();
    if (!self.canCreate(input)) {
      callback();
      return false;
    }
    self.lock();
    var created = false;
    var create = (data) => {
      self.unlock();
      if (!data || typeof data !== "object")
        return callback();
      var value = hash_key(data[self.settings.valueField]);
      if (typeof value !== "string") {
        return callback();
      }
      self.setTextboxValue();
      self.addOption(data);
      self.setCaret(caret);
      self.addItem(value);
      self.refreshOptions(triggerDropdown && self.settings.mode !== "single");
      callback(data);
      created = true;
    };
    if (typeof self.settings.create === "function") {
      output = self.settings.create.call(this, input, create);
    } else {
      output = {
        [self.settings.labelField]: input,
        [self.settings.valueField]: input
      };
    }
    if (!created) {
      create(output);
    }
    return true;
  }
  refreshItems() {
    var self = this;
    self.lastQuery = null;
    if (self.isSetup) {
      self.addItems(self.items);
    }
    self.updateOriginalInput();
    self.refreshState();
  }
  refreshState() {
    var self = this;
    self.refreshValidityState();
    var isFull = self.isFull();
    var isLocked = self.isLocked;
    self.wrapper.classList.toggle("rtl", self.rtl);
    var classList = self.control.classList;
    classList.toggle("focus", self.isFocused);
    classList.toggle("disabled", self.isDisabled);
    classList.toggle("required", self.isRequired);
    classList.toggle("invalid", self.isInvalid);
    classList.toggle("locked", isLocked);
    classList.toggle("full", isFull);
    classList.toggle("not-full", !isFull);
    classList.toggle("input-active", self.isFocused && !self.isInputHidden);
    classList.toggle("dropdown-active", self.isOpen);
    classList.toggle("has-options", isEmptyObject(self.options));
    classList.toggle("has-items", self.items.length > 0);
  }
  refreshValidityState() {
    var self = this;
    if (!self.input.checkValidity) {
      return;
    }
    if (this.isRequired) {
      self.input.required = true;
    }
    var invalid = !self.input.checkValidity();
    self.isInvalid = invalid;
    self.control_input.required = invalid;
    if (this.isRequired) {
      self.input.required = !invalid;
    }
  }
  isFull() {
    return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
  }
  updateOriginalInput(opts = {}) {
    const self = this;
    var i, value, option, option_el, label;
    if (self.is_select_tag) {
      let AddSelected = function(option_el2, value2, label2) {
        if (!option_el2) {
          option_el2 = getDom('<option value="' + escape_html(value2) + '">' + escape_html(label2) + "</option>");
        }
        self.input.prepend(option_el2);
        selected.push(option_el2);
        setAttr(option_el2, {
          selected: "true"
        });
        option_el2.selected = true;
        return option_el2;
      };
      const selected = [];
      self.input.querySelectorAll("option[selected]").forEach((option_el2) => {
        setAttr(option_el2, {
          selected: null
        });
        option_el2.selected = false;
      });
      if (self.items.length == 0 && self.settings.mode == "single" && !self.isRequired) {
        option_el = self.input.querySelector('option[value=""]');
        AddSelected(option_el, "", "");
      } else {
        for (i = self.items.length - 1; i >= 0; i--) {
          value = self.items[i];
          option = self.options[value];
          label = option[self.settings.labelField] || "";
          if (selected.includes(option.$option)) {
            const reuse_opt = self.input.querySelector(`option[value="${addSlashes(value)}"]:not([selected])`);
            AddSelected(reuse_opt, value, label);
          } else {
            option.$option = AddSelected(option.$option, value, label);
          }
        }
      }
    } else {
      self.input.value = self.getValue();
    }
    if (self.isSetup) {
      if (!opts.silent) {
        self.trigger("change", self.getValue());
      }
    }
  }
  open() {
    var self = this;
    if (self.isLocked || self.isOpen || self.settings.mode === "multi" && self.isFull())
      return;
    self.isOpen = true;
    setAttr(self.control_input, {
      "aria-expanded": "true"
    });
    self.refreshState();
    applyCSS(self.dropdown, {
      visibility: "hidden",
      display: "block"
    });
    self.positionDropdown();
    applyCSS(self.dropdown, {
      visibility: "visible",
      display: "block"
    });
    self.focus();
    self.trigger("dropdown_open", self.dropdown);
  }
  close(setTextboxValue = true) {
    var self = this;
    var trigger = self.isOpen;
    if (setTextboxValue) {
      self.setTextboxValue();
      if (self.settings.mode === "single" && self.items.length) {
        self.hideInput();
        if (!self.tab_key) {
          self.blur();
        }
      }
    }
    self.isOpen = false;
    setAttr(self.control_input, {
      "aria-expanded": "false"
    });
    applyCSS(self.dropdown, {
      display: "none"
    });
    if (self.settings.hideSelected) {
      self.clearActiveOption();
    }
    self.refreshState();
    if (trigger)
      self.trigger("dropdown_close", self.dropdown);
  }
  positionDropdown() {
    if (this.settings.dropdownParent !== "body") {
      return;
    }
    var context = this.control;
    var rect = context.getBoundingClientRect();
    var top = context.offsetHeight + rect.top + window.scrollY;
    var left = rect.left + window.scrollX;
    applyCSS(this.dropdown, {
      width: rect.width + "px",
      top: top + "px",
      left: left + "px"
    });
  }
  clear(silent) {
    var self = this;
    if (!self.items.length)
      return;
    var items = self.controlChildren();
    for (const item of items) {
      self.removeItem(item, true);
    }
    self.showInput();
    if (!silent)
      self.updateOriginalInput();
    self.trigger("clear");
  }
  insertAtCaret(el) {
    var self = this;
    var caret = Math.min(self.caretPos, self.items.length);
    var target = self.control;
    if (caret === 0) {
      target.insertBefore(el, target.firstChild);
    } else {
      target.insertBefore(el, target.children[caret]);
    }
    self.setCaret(caret + 1);
  }
  deleteSelection(e) {
    var direction, selection, caret, tail;
    var self = this;
    direction = e && e.keyCode === KEY_BACKSPACE ? -1 : 1;
    selection = getSelection(self.control_input);
    const rm_items = [];
    if (self.activeItems.length) {
      tail = getTail(self.activeItems, direction);
      caret = nodeIndex(tail);
      if (direction > 0) {
        caret++;
      }
      for (const item of self.activeItems) {
        rm_items.push(item);
      }
    } else if ((self.isFocused || self.settings.mode === "single") && self.items.length) {
      const items = self.controlChildren();
      if (direction < 0 && selection.start === 0 && selection.length === 0) {
        rm_items.push(items[self.caretPos - 1]);
      } else if (direction > 0 && selection.start === self.inputValue().length) {
        rm_items.push(items[self.caretPos]);
      }
    }
    const values = rm_items.map((item) => item.dataset.value);
    if (!values.length || typeof self.settings.onDelete === "function" && self.settings.onDelete.call(self, values, e) === false) {
      return false;
    }
    preventDefault(e, true);
    if (typeof caret !== "undefined") {
      self.setCaret(caret);
    }
    while (rm_items.length) {
      self.removeItem(rm_items.pop());
    }
    self.showInput();
    self.positionDropdown();
    self.refreshOptions(false);
    return true;
  }
  advanceSelection(direction, e) {
    var idx, last_active, adjacent, self = this;
    if (self.rtl)
      direction *= -1;
    if (self.inputValue().length)
      return;
    if (isKeyDown(KEY_SHORTCUT, e) || isKeyDown("shiftKey", e)) {
      last_active = self.getLastActive(direction);
      if (last_active) {
        if (!last_active.classList.contains("active")) {
          adjacent = last_active;
        } else {
          adjacent = self.getAdjacent(last_active, direction, "item");
        }
      } else if (direction > 0) {
        adjacent = self.control_input.nextElementSibling;
      } else {
        adjacent = self.control_input.previousElementSibling;
      }
      if (adjacent) {
        if (adjacent.classList.contains("active")) {
          self.removeActiveItem(last_active);
        }
        self.setActiveItemClass(adjacent);
      }
    } else if (self.isFocused && !self.activeItems.length) {
      self.setCaret(self.caretPos + direction);
    } else {
      last_active = self.getLastActive(direction);
      if (last_active) {
        idx = nodeIndex(last_active);
        self.setCaret(direction > 0 ? idx + 1 : idx);
        self.setActiveItem();
      }
    }
  }
  getLastActive(direction) {
    let last_active = this.control.querySelector(".last-active");
    if (last_active) {
      return last_active;
    }
    var result = this.control.querySelectorAll(".active");
    if (result) {
      return getTail(result, direction);
    }
  }
  setCaret(new_pos) {
    var self = this;
    if (self.settings.mode === "single" || self.settings.controlInput) {
      new_pos = self.items.length;
    } else {
      new_pos = Math.max(0, Math.min(self.items.length, new_pos));
      if (new_pos != self.caretPos && !self.isPending) {
        self.controlChildren().forEach((child, j) => {
          if (j < new_pos) {
            self.control_input.insertAdjacentElement("beforebegin", child);
          } else {
            self.control.appendChild(child);
          }
        });
      }
    }
    self.caretPos = new_pos;
  }
  controlChildren() {
    return Array.from(this.control.getElementsByClassName(this.settings.itemClass));
  }
  lock() {
    this.close();
    this.isLocked = true;
    this.refreshState();
  }
  unlock() {
    this.isLocked = false;
    this.refreshState();
  }
  disable() {
    var self = this;
    self.input.disabled = true;
    self.control_input.disabled = true;
    self.control_input.tabIndex = -1;
    self.isDisabled = true;
    self.lock();
  }
  enable() {
    var self = this;
    self.input.disabled = false;
    self.control_input.disabled = false;
    self.control_input.tabIndex = self.tabIndex;
    self.isDisabled = false;
    self.unlock();
  }
  destroy() {
    var self = this;
    var revertSettings = self.revertSettings;
    self.trigger("destroy");
    self.off();
    self.wrapper.remove();
    self.dropdown.remove();
    self.input.innerHTML = revertSettings.innerHTML;
    self.input.tabIndex = revertSettings.tabIndex;
    removeClasses(self.input, "tomselected");
    setAttr(self.input, {
      hidden: null
    });
    self.input.required = this.isRequired;
    self._destroy();
    delete self.input.tomselect;
  }
  render(templateName, data) {
    if (typeof this.settings.render[templateName] !== "function") {
      return null;
    }
    return this._render(templateName, data);
  }
  _render(templateName, data) {
    var value = "", id, html;
    const self = this;
    if (templateName === "option" || templateName === "item") {
      value = get_hash(data[self.settings.valueField]);
      html = self.rendered(templateName, value);
      if (html) {
        return html;
      }
    }
    html = self.settings.render[templateName].call(this, data, escape_html);
    if (html == null) {
      return html;
    }
    html = getDom(html);
    if (templateName === "option" || templateName === "option_create") {
      if (data[self.settings.disabledField]) {
        setAttr(html, {
          "aria-disabled": "true"
        });
      } else {
        setAttr(html, {
          "data-selectable": ""
        });
      }
    } else if (templateName === "optgroup") {
      id = data.group[self.settings.optgroupValueField];
      setAttr(html, {
        "data-group": id
      });
      if (data.group[self.settings.disabledField]) {
        setAttr(html, {
          "data-disabled": ""
        });
      }
    }
    if (templateName === "option" || templateName === "item") {
      setAttr(html, {
        "data-value": value
      });
      if (templateName === "item") {
        addClasses(html, self.settings.itemClass);
      } else {
        addClasses(html, self.settings.optionClass);
        setAttr(html, {
          role: "option",
          id: data.$id
        });
      }
      self.renderCache[templateName][value] = html;
    }
    return html;
  }
  rendered(templateName, value) {
    return value !== null && this.renderCache[templateName].hasOwnProperty(value) ? this.renderCache[templateName][value] : null;
  }
  clearCache(templateName) {
    var self = this;
    if (templateName === void 0 || "option") {
      for (let key in self.options) {
        const el = self.getOption(key);
        if (el)
          el.remove();
      }
    }
    if (templateName === void 0) {
      self.renderCache = {
        "item": {},
        "option": {}
      };
    } else {
      self.renderCache[templateName] = {};
    }
  }
  canCreate(input) {
    return this.settings.create && input.length > 0 && this.settings.createFilter.call(this, input);
  }
  hook(when, method, new_fn) {
    var self = this;
    var orig_method = self[method];
    self[method] = function() {
      var result, result_new;
      if (when === "after") {
        result = orig_method.apply(self, arguments);
      }
      result_new = new_fn.apply(self, arguments);
      if (when === "instead") {
        return result_new;
      }
      if (when === "before") {
        result = orig_method.apply(self, arguments);
      }
      return result;
    };
  }
};
TomSelect.define("change_listener", function() {
  const self = this;
  const joined = (arr) => arr.join(self.settings.delimiter);
  addEvent(self.input, "change", () => {
    var settings = getSettings(self.input, {
      delimiter: self.settings.delimiter
    });
    if (joined(self.items) == joined(settings.items)) {
      return;
    }
    self.setupOptions(settings.options, settings.optgroups);
    self.setValue(settings.items);
  });
});
TomSelect.define("checkbox_options", function() {
  var self = this;
  var orig_onOptionSelect = self.onOptionSelect;
  self.settings.hideSelected = false;
  var UpdateCheckbox = function UpdateCheckbox2(option) {
    setTimeout(() => {
      var checkbox = option.querySelector("input");
      if (option.classList.contains("selected")) {
        checkbox.checked = true;
      } else {
        checkbox.checked = false;
      }
    }, 1);
  };
  self.hook("after", "setupTemplates", () => {
    var orig_render_option = self.settings.render.option;
    self.settings.render.option = (data, escape_html2) => {
      var rendered = getDom(orig_render_option.call(self, data, escape_html2));
      var checkbox = document.createElement("input");
      checkbox.addEventListener("click", function(evt) {
        preventDefault(evt);
      });
      checkbox.type = "checkbox";
      const hashed = hash_key(data[self.settings.valueField]);
      if (hashed && self.items.indexOf(hashed) > -1) {
        checkbox.checked = true;
      }
      rendered.prepend(checkbox);
      return rendered;
    };
  });
  self.on("item_remove", (value) => {
    var option = self.getOption(value);
    if (option) {
      option.classList.remove("selected");
      UpdateCheckbox(option);
    }
  });
  self.hook("instead", "onOptionSelect", (evt, option) => {
    if (option.classList.contains("selected")) {
      option.classList.remove("selected");
      self.removeItem(option.dataset.value);
      self.refreshOptions();
      preventDefault(evt, true);
      return;
    }
    orig_onOptionSelect.call(self, evt, option);
    UpdateCheckbox(option);
  });
});
TomSelect.define("clear_button", function(userOptions) {
  const self = this;
  const options = Object.assign({
    className: "clear-button",
    title: "Clear All",
    html: (data) => {
      return `<div class="${data.className}" title="${data.title}">&times;</div>`;
    }
  }, userOptions);
  self.on("initialize", () => {
    var button = getDom(options.html(options));
    button.addEventListener("click", (evt) => {
      self.clear();
      evt.preventDefault();
      evt.stopPropagation();
    });
    self.control.appendChild(button);
  });
});
TomSelect.define("drag_drop", function() {
  var self = this;
  if (!$.fn.sortable)
    throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');
  if (self.settings.mode !== "multi")
    return;
  var orig_lock = self.lock;
  var orig_unlock = self.unlock;
  self.hook("instead", "lock", () => {
    var sortable = $(self.control).data("sortable");
    if (sortable)
      sortable.disable();
    return orig_lock.call(self);
  });
  self.hook("instead", "unlock", () => {
    var sortable = $(self.control).data("sortable");
    if (sortable)
      sortable.enable();
    return orig_unlock.call(self);
  });
  self.on("initialize", () => {
    var $control = $(self.control).sortable({
      items: "[data-value]",
      forcePlaceholderSize: true,
      disabled: self.isLocked,
      start: (e, ui) => {
        ui.placeholder.css("width", ui.helper.css("width"));
        $control.css({
          overflow: "visible"
        });
      },
      stop: () => {
        $control.css({
          overflow: "hidden"
        });
        var values = [];
        $control.children("[data-value]").each(function() {
          if (this.dataset.value)
            values.push(this.dataset.value);
        });
        self.setValue(values);
      }
    });
  });
});
TomSelect.define("dropdown_header", function(userOptions) {
  const self = this;
  const options = Object.assign({
    title: "Untitled",
    headerClass: "dropdown-header",
    titleRowClass: "dropdown-header-title",
    labelClass: "dropdown-header-label",
    closeClass: "dropdown-header-close",
    html: (data) => {
      return '<div class="' + data.headerClass + '"><div class="' + data.titleRowClass + '"><span class="' + data.labelClass + '">' + data.title + '</span><a class="' + data.closeClass + '">&times;</a></div></div>';
    }
  }, userOptions);
  self.on("initialize", () => {
    var header = getDom(options.html(options));
    var close_link = header.querySelector("." + options.closeClass);
    if (close_link) {
      close_link.addEventListener("click", (evt) => {
        preventDefault(evt, true);
        self.close();
      });
    }
    self.dropdown.insertBefore(header, self.dropdown.firstChild);
  });
});
TomSelect.define("dropdown_input", function() {
  var self = this;
  var input = self.settings.controlInput || '<input type="text" autocomplete="off" class="dropdown-input" />';
  input = getDom(input);
  if (self.settings.placeholder) {
    setAttr(input, {
      placeholder: self.settings.placeholder
    });
  }
  self.settings.controlInput = input;
  self.settings.shouldOpen = true;
  self.on("initialize", () => {
    addEvent(self.wrapper, "focus", (evt) => {
      self.onFocus(evt);
    });
    const setTabIndex = () => {
      setAttr(self.wrapper, {
        tabindex: self.input.disabled ? "-1" : self.tabIndex
      });
    };
    self.on("dropdown_close", setTabIndex);
    self.on("dropdown_open", () => setAttr(self.wrapper, {
      tabindex: "-1"
    }));
    setTabIndex();
    addEvent(self.wrapper, "keypress", (evt) => {
      if (self.control.contains(evt.target)) {
        return;
      }
      if (self.dropdown.contains(evt.target)) {
        return;
      }
      switch (evt.keyCode) {
        case KEY_RETURN:
          self.onClick();
          return;
      }
    });
    let div = getDom('<div class="dropdown-input-wrap">');
    div.appendChild(input);
    self.dropdown.insertBefore(div, self.dropdown.firstChild);
  });
});
TomSelect.define("input_autogrow", function() {
  var self = this;
  self.on("initialize", () => {
    var test_input = document.createElement("span");
    var control = self.control_input;
    test_input.style.cssText = "position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ";
    self.wrapper.appendChild(test_input);
    var transfer_styles = ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"];
    for (const style_name of transfer_styles) {
      test_input.style[style_name] = control.style[style_name];
    }
    var resize = () => {
      if (self.items.length > 0) {
        test_input.textContent = control.value;
        control.style.width = test_input.clientWidth + "px";
      } else {
        control.style.width = "";
      }
    };
    resize();
    self.on("update item_add item_remove", resize);
    addEvent(control, "input", resize);
    addEvent(control, "keyup", resize);
    addEvent(control, "blur", resize);
    addEvent(control, "update", resize);
  });
});
TomSelect.define("no_backspace_delete", function() {
  var self = this;
  var orig_deleteSelection = self.deleteSelection;
  this.hook("instead", "deleteSelection", (evt) => {
    if (self.activeItems.length) {
      return orig_deleteSelection.call(self, evt);
    }
    return false;
  });
});
TomSelect.define("no_active_items", function() {
  this.hook("instead", "setActiveItem", () => {
  });
  this.hook("instead", "selectAll", () => {
  });
});
TomSelect.define("optgroup_columns", function() {
  var self = this;
  var orig_keydown = self.onKeyDown;
  self.hook("instead", "onKeyDown", (evt) => {
    var index, option, options, optgroup;
    if (!self.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {
      return orig_keydown.call(self, evt);
    }
    optgroup = parentMatch(self.activeOption, "[data-group]");
    index = nodeIndex(self.activeOption, "[data-selectable]");
    if (!optgroup) {
      return;
    }
    if (evt.keyCode === KEY_LEFT) {
      optgroup = optgroup.previousSibling;
    } else {
      optgroup = optgroup.nextSibling;
    }
    if (!optgroup) {
      return;
    }
    options = optgroup.querySelectorAll("[data-selectable]");
    option = options[Math.min(options.length - 1, index)];
    if (option) {
      self.setActiveOption(option);
    }
  });
});
TomSelect.define("remove_button", function(userOptions) {
  const options = Object.assign({
    label: "&times;",
    title: "Remove",
    className: "remove",
    append: true
  }, userOptions);
  var self = this;
  if (!options.append) {
    return;
  }
  var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + "</a>";
  self.hook("after", "setupTemplates", () => {
    var orig_render_item = self.settings.render.item;
    self.settings.render.item = (data, escape) => {
      var rendered = getDom(orig_render_item.call(self, data, escape));
      var close_button = getDom(html);
      rendered.appendChild(close_button);
      addEvent(close_button, "mousedown", (evt) => {
        preventDefault(evt, true);
      });
      addEvent(close_button, "click", (evt) => {
        preventDefault(evt, true);
        if (self.isLocked)
          return;
        var value = rendered.dataset.value;
        self.removeItem(value);
        self.refreshOptions(false);
      });
      return rendered;
    };
  });
});
TomSelect.define("restore_on_backspace", function(userOptions) {
  const self = this;
  const options = Object.assign({
    text: (option) => {
      return option[self.settings.labelField];
    }
  }, userOptions);
  self.on("item_remove", function(value) {
    if (self.control_input.value.trim() === "") {
      var option = self.options[value];
      if (option) {
        self.setTextboxValue(options.text.call(self, option));
      }
    }
  });
});
TomSelect.define("virtual_scroll", function() {
  const self = this;
  const orig_canLoad = self.canLoad;
  const orig_clearActiveOption = self.clearActiveOption;
  const orig_loadCallback = self.loadCallback;
  var pagination = {};
  var dropdown_content;
  var loading_more = false;
  if (!self.settings.firstUrl) {
    throw "virtual_scroll plugin requires a firstUrl() method";
  }
  self.settings.sortField = [{
    field: "$order"
  }, {
    field: "$score"
  }];
  function canLoadMore(query) {
    if (typeof self.settings.maxOptions === "number" && dropdown_content.children.length >= self.settings.maxOptions) {
      return false;
    }
    if (query in pagination && pagination[query]) {
      return true;
    }
    return false;
  }
  self.setNextUrl = function(value, next_url) {
    pagination[value] = next_url;
  };
  self.getUrl = function(query) {
    if (query in pagination) {
      const next_url = pagination[query];
      pagination[query] = false;
      return next_url;
    }
    pagination = {};
    return self.settings.firstUrl(query);
  };
  self.hook("instead", "clearActiveOption", () => {
    if (loading_more) {
      return;
    }
    return orig_clearActiveOption.call(self);
  });
  self.hook("instead", "canLoad", (query) => {
    if (!(query in pagination)) {
      return orig_canLoad.call(self, query);
    }
    return canLoadMore(query);
  });
  self.hook("instead", "loadCallback", (options, optgroups) => {
    if (!loading_more) {
      self.clearOptions();
    }
    orig_loadCallback.call(self, options, optgroups);
    loading_more = false;
  });
  self.hook("after", "refreshOptions", () => {
    const query = self.lastValue;
    var option;
    if (canLoadMore(query)) {
      option = self.render("loading_more", {
        query
      });
      if (option)
        option.setAttribute("data-selectable", "");
    } else if (query in pagination && !dropdown_content.querySelector(".no-results")) {
      option = self.render("no_more_results", {
        query
      });
    }
    if (option) {
      addClasses(option, self.settings.optionClass);
      dropdown_content.append(option);
    }
  });
  self.on("initialize", () => {
    dropdown_content = self.dropdown_content;
    self.settings.render = Object.assign({}, {
      loading_more: function() {
        return `<div class="loading-more-results">Loading more results ... </div>`;
      },
      no_more_results: function() {
        return `<div class="no-more-results">No more results</div>`;
      }
    }, self.settings.render);
    dropdown_content.addEventListener("scroll", function() {
      const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);
      if (scroll_percent < 0.95) {
        return;
      }
      if (!canLoadMore(self.lastValue)) {
        return;
      }
      if (loading_more)
        return;
      loading_more = true;
      self.load.call(self, self.lastValue);
    });
  });
});
var tom_select_complete_default = TomSelect;

// dep:tom-select
var tom_select_default = tom_select_complete_default;
export {
  tom_select_default as default
};
//# sourceMappingURL=tom-select.js.map
